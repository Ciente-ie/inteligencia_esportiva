function processAndStoreLoadData(dataToProcess) {
    const dataByAthlete = dataToProcess.reduce((acc, row) => {
        if (!acc[row.atleta_id]) acc[row.atleta_id] = [];
        acc[row.atleta_id].push(row);
        return acc;
    }, {});

    let allMicrocyclesForTeam = new Set();
    Object.values(dataByAthlete).flat().forEach(row => {
        if(row.microciclo_id) allMicrocyclesForTeam.add(row.microciclo_id);
    });
    
    athleteMicrocycleData = {};

    for (const athleteId in dataByAthlete) {
        // AJUSTE 1: Coleta de todo o histórico de dados do atleta para o cálculo do desvio padrão.
        const allAthleteData = fullCargaData.filter(d => d.atleta_id === athleteId);
        const allDailyLoads = allAthleteData.map(e => (e.pse_sessao || 0) * (e.duracao_sessao_min || 0));
        const historicalStdDevForAthlete = getStats(allDailyLoads).stdDev;

        const microcycles = allAthleteData.reduce((acc, row) => {
            if (!row.microciclo_id) return acc;
            if (!acc[row.microciclo_id]) acc[row.microciclo_id] = { entries: [], minDate: row.data };
            acc[row.microciclo_id].entries.push(row);
            if (new Date(`${row.data}T00:00:00`) < new Date(`${acc[row.microciclo_id].minDate}T00:00:00`)) {
                acc[row.microciclo_id].minDate = row.data;
            }
            return acc;
        }, {});

        athleteMicrocycleData[athleteId] = Object.entries(microcycles)
            .sort(([, a], [, b]) => new Date(`${a.minDate}T00:00:00`) - new Date(`${b.minDate}T00:00:00`))
            .map(([id, cycleData]) => {
                const dailyEntries = cycleData.entries.map(e => ({
                    date: e.data,
                    load: (e.pse_sessao || 0) * (e.duracao_sessao_min || 0)
                }));
                
                // Média e soma são calculadas apenas para o microciclo atual.
                const loadStats = getStats(dailyEntries.map(e => e.load));
                
                // AJUSTE 2: Cálculo da monotonia usando a média da semana e o desvio padrão histórico.
                let monotony = 0;
                if (loadStats.mean > 0 && historicalStdDevForAthlete > 0) {
                    monotony = loadStats.mean / historicalStdDevForAthlete;
                } else if (loadStats.mean > 0 && (historicalStdDevForAthlete === 0 || isNaN(historicalStdDevForAthlete)) && loadStats.count > 1) {
                    // Fallback para quando a variação histórica é zero, mas há carga na semana atual.
                    // Isso indica uma mudança de um estado constante, então uma monotonia alta é lógica.
                    monotony = 10; 
                }

                return {
                    microciclo_id: id,
                    totalLoad: loadStats.sum, 
                    monotony: monotony,
                    // O cálculo do Strain é corrigido automaticamente, pois agora usa a monotonia correta.
                    strain: loadStats.sum * monotony,
                    dailyEntries: dailyEntries
                };
            });
    }

    const sortedMicrocycles = sortWeeks([...allMicrocyclesForTeam]);
    renderFilter(sortedMicrocycles);
}
